# Copyright (c) YugaByte, Inc.
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-yugaware-global-config
  labels:
    app: {{ template "yugaware.name" . }}
    chart: {{ template "yugaware.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Values.helm2Legacy | ternary "Tiller" (.Release.Service | quote) }}
data:
  postgres_user: "postgres"
  postgres_password: "{{ include "getOrGeneratePassword" (dict "Namespace" .Release.Namespace "Kind" "ConfigMap" "Name" (printf "%s%s" .Release.Name "-yugaware-global-config") "Key" "postgres_password") }}"
  postgres_db: "yugaware"
  app_secret: "{{ b64enc (randAlphaNum 64) }}"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-yugaware-app-config
  labels:
    app: {{ template "yugaware.name" . }}
    chart: {{ template "yugaware.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Values.helm2Legacy | ternary "Tiller" (.Release.Service | quote) }}
data:
  application.docker.conf: |
    include classpath("application.common.conf")
    play.crypto.secret=${APP_SECRET}
    play.i18n.langs = [ "en" ]
    pidfile.path = "/dev/null"
    play.evolutions.enabled=false
    play.modules.enabled += "org.flywaydb.play.PlayModule"
    play.logger.includeConfigProperties=true
    log.override.path = "/opt/yugabyte/yugaware/data/logs"

    db {
  {{ if eq .Values.ip_version_support "v6_only" }}
      default.host="::1"
      default.url="jdbc:postgresql://[::1]:"${db.default.port}"/"${POSTGRES_DB}
  {{ else }}
      default.host="127.0.0.1"
      default.url="jdbc:postgresql://127.0.0.1:"${db.default.port}"/"${POSTGRES_DB}
  {{ end }}
      default.driver=org.postgresql.Driver
      default.username=${POSTGRES_USER}
      default.password=${POSTGRES_PASSWORD}
      default.logStatements=true
      default.migration.initOnMigrate=true
      default.migration.auto=true
    }
    ebean {
      default = ["com.yugabyte.yw.models.*"]
    }

    play.modules.enabled += "org.flywaydb.play.PlayModule"

    yb {
      devops.home = /opt/yugabyte/devops
      metrics.host = "{{ eq .Values.ip_version_support "v6_only" | ternary "[::1]" "127.0.0.1" }}"
      metrics.url = "http://"${yb.metrics.host}":9090/api/v1"
      storage.path = /opt/yugabyte/yugaware/data
      docker.network = bridge
      seedData = false
      swamper.targetPath = /opt/yugabyte/prometheus/targets
      security.enable_auth_for_proxy_metrics = {{ .Values.yugaware.enableProxyMetricsAuth }}
      multiTenant = {{ .Values.yugaware.multiTenant }}
      releases.path = "/opt/yugabyte/releases"
      docker.release = "/opt/yugabyte/release"
      # TODO(bogdan): need this extra level for installing from local...
      thirdparty.packagePath = /opt/third-party
      helm.package = "{{ .Values.helm.package }}"
      helm.timeout_secs = {{ .Values.helm.timeout }}
      health.check_interval_ms = 300000
      health.status_interval_ms = 43200000
      health.default_email = "{{ .Values.yugaware.health.email }}"
      health.ses_email_username = "{{ .Values.yugaware.health.username }}"
      health.ses_email_password = "{{ .Values.yugaware.health.password }}"
    }

    play.filters {
      # CSRF config
      csrf {
        cookie {
          # If non null, the CSRF token will be placed in a cookie with this name
          name = "csrfCookie"
          # Whether the cookie should be set to secure
          secure = false
          # Whether the cookie should have the HTTP only flag set
          httpOnly = false
        }
        # Whether to bypass CSRF check if CORS check is satisfied
        bypassCorsTrustedOrigins = false
        header {
          # The name of the header to accept CSRF tokens from.
          name = "Csrf-Token"
        }
      }
      # CORS config
      cors {
        pathPrefixes = ["/"]
{{- if .Values.tls.enabled }}
        allowedOrigins = ["https://{{ .Values.tls.hostname }}"]
{{- else }}
        allowedOrigins = ["http://{{ .Values.tls.hostname }}"]
{{- end }}
        # Server allows cookies/credentials to be sent with cross-origin requests
        supportsCredentials=true
        allowedHttpMethods = ["GET", "POST", "PUT", "OPTIONS", "DELETE"]
        allowedHttpHeaders = ["Accept", "Origin", "Content-Type", "X-Auth-Token", "X-AUTH-YW-API-TOKEN", ${play.filters.csrf.header.name}]
      }
    }

{{- if .Values.tls.enabled }}
---
apiVersion: v1
kind: Secret
metadata:
  name: {{ .Release.Name }}-yugaware-tls-cert
  labels:
    app: "{{ template "yugaware.name" . }}"
    chart: "{{ template "yugaware.chart" . }}"
    release: {{ .Release.Name | quote }}
    heritage: {{ .Release.Service | quote }}
type: Opaque
data:
  server.crt: {{ .Values.tls.certificate }}
  server.key: {{ .Values.tls.key }}
{{- end }}

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-yugaware-nginx-config
  labels:
    app: {{ template "yugaware.name" . }}
    chart: {{ template "yugaware.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Values.helm2Legacy | ternary "Tiller" (.Release.Service | quote) }}
data:
  default.conf: |
    server {
{{- if .Values.tls.enabled }}
      listen       8443 ssl;
      ssl_certificate /opt/certs/server.crt;
      ssl_certificate_key /opt/certs/server.key;
{{- if .Values.tls.sslProtocols }}
      ssl_protocols {{ include "validate_nginx_ssl_protocols" . }};
{{- end }}
      server_name  {{ .Values.tls.hostname }};
{{- else }}
      listen       {{ eq .Values.ip_version_support "v6_only" | ternary "[::]:8080" "8080" }};
      server_name  {{ .Values.tls.hostname }};
{{- end }}
      proxy_http_version 1.1;
      proxy_set_header X-Real-IP  $remote_addr;
      proxy_set_header X-Forwarded-For $remote_addr;
      proxy_set_header Host $host;

      location / {
        proxy_pass http://{{ eq .Values.ip_version_support "v6_only" | ternary "[::1]" "127.0.0.1" }}:9000;
      }
      location ~ /settings/ha/internal/upload$ {
        proxy_pass http://{{ eq .Values.ip_version_support "v6_only" | ternary "[::1]" "127.0.0.1" }}:9000;
        client_max_body_size {{ .Values.nginx.upload_size }};
      }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-yugaware-prometheus-config
  labels:
    app: {{ template "yugaware.name" . }}
    chart: {{ template "yugaware.chart" . }}
    release: {{ .Release.Name }}
    heritage: {{ .Values.helm2Legacy | ternary "Tiller" (.Release.Service | quote) }}
data:
  prometheus.yml: |
    global:
        scrape_interval:     10s
        evaluation_interval: 10s
    scrape_configs:
      {{- if .Values.ocpCompatibility.enabled }}
      - job_name: "ocp-prometheus-federated"
        scheme: https

        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          insecure_skip_verify: true
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

        honor_labels: true
        metrics_path: "/federate"

        params:
          'match[]':
            # kubelet metrics
            - 'kubelet_volume_stats_used_bytes{persistentvolumeclaim=~"(.*)-yb-(.*)"}'
            - 'kubelet_volume_stats_capacity_bytes{persistentvolumeclaim=~"(.*)-yb-(.*)"}'
            # kubelet cadvisor metrics
            - 'container_cpu_usage_seconds_total{pod=~"(.*)yb-(.*)"}'
            - 'container_memory_working_set_bytes{pod=~"(.*)yb-(.*)"}'
            # kube-state-metrics
            - 'kube_pod_container_resource_requests_cpu_cores{pod=~"(.*)yb-(.*)"}'

        static_configs:
          - targets:
            - "prometheus-k8s.openshift-monitoring.svc:9091"

        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"
          - source_labels: ["pod"]
            regex: "(.*)"
            target_label: "pod_name"
            replacement: "$1"
          - source_labels: ["container"]
            regex: "(.*)"
            target_label: "container_name"
            replacement: "$1"

      {{- else }}

      - job_name: 'kubernetes-nodes'

        scheme: https

        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

        kubernetes_sd_configs:
        - role: node

        relabel_configs:
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - target_label: __address__
          replacement: kubernetes.default.svc:443
        - source_labels: [__meta_kubernetes_node_name]
          regex: (.+)
          target_label: __metrics_path__
          replacement: /api/v1/nodes/${1}/proxy/metrics
        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"
          - source_labels: ["pod"]
            regex: "(.*)"
            target_label: "pod_name"
            replacement: "$1"
          - source_labels: ["container"]
            regex: "(.*)"
            target_label: "container_name"
            replacement: "$1"

      - job_name: 'kube-state-metrics'
        static_configs:
        - targets: ['kube-state-metrics.kube-system.svc.{{.Values.domainName}}:8080']
        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"
          - source_labels: ["pod"]
            regex: "(.*)"
            target_label: "pod_name"
            replacement: "$1"
          - source_labels: ["container"]
            regex: "(.*)"
            target_label: "container_name"
            replacement: "$1"

      - job_name: 'kubernetes-cadvisor'

        scheme: https

        tls_config:
          ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token

        kubernetes_sd_configs:
        - role: node

        relabel_configs:
        - action: labelmap
          regex: __meta_kubernetes_node_label_(.+)
        - target_label: __address__
          replacement: kubernetes.default.svc:443
        - source_labels: [__meta_kubernetes_node_name]
          regex: (.+)
          target_label: __metrics_path__
          replacement: /api/v1/nodes/${1}/proxy/metrics/cadvisor
        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"
          - source_labels: ["pod"]
            regex: "(.*)"
            target_label: "pod_name"
            replacement: "$1"
          - source_labels: ["container"]
            regex: "(.*)"
            target_label: "container_name"
            replacement: "$1"

      {{- end }}

      - job_name: 'platform'
        metrics_path: "/api/v1/prometheus_metrics"
        static_configs:
          - targets: [
            '{{ eq .Values.ip_version_support "v6_only" | ternary "[::1]" "127.0.0.1" }}:9000'
          ]

      - job_name: "node"
        file_sd_configs:
          - files:
            - '/opt/yugabyte/prometheus/targets/node.*.json'
        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"

      - job_name: "yugabyte"
        metrics_path: "/prometheus-metrics"
        params:
          # Enable priority regex on all tables
          # URL encoding done by prometheus
          max_tables_metrics_breakdowns: ["0"]
          priority_regex:
            - "rocksdb_(number_db_(next|seek)\
            |block_cache_(add|single_touch_add|multi_touch_add)\
            |current_version_(sst_files_size|num_sst_files)\
            |db_([^_]+_micros_[^_]+|mutex_wait_micros)|block_cache_(hit|miss)\
            |bloom_filter_(checked|useful)|stall_micros|flush_write_bytes\
            |compact_[^_]+_bytes|compaction_times_micros_[^_]+\
            |numfiles_in_singlecompaction_[^_]+)\
            |async_replication_[^_]+_lag_micros|transaction_conflicts\
            |majority_sst_files_rejections|expired_transactions
            |log_(sync_latency_[^_]+|group_commit_latency_[^_]+\
            |append_latency_[^_]+|bytes_logged|reader_bytes_read\
            |append_latency_count|sync_latency_count|cache_size|cache_num_ops)\
            |glog_[^_]+_messages"
        file_sd_configs:
          - files:
            - '/opt/yugabyte/prometheus/targets/yugabyte.*.json'
        metric_relabel_configs:
          # Save the name of the metric so we can group_by since we cannot by __name__ directly...
          - source_labels: ["__name__"]
            regex: "(.*)"
            target_label: "saved_name"
            replacement: "$1"
          # The following basically retrofit the handler_latency_* metrics to label format.
          - source_labels: ["__name__"]
            regex: "handler_latency_(yb_[^_]*)_([^_]*)_([^_]*)(.*)"
            target_label: "server_type"
            replacement: "$1"
          - source_labels: ["__name__"]
            regex: "handler_latency_(yb_[^_]*)_([^_]*)_([^_]*)(.*)"
            target_label: "service_type"
            replacement: "$2"
          - source_labels: ["__name__"]
            regex: "handler_latency_(yb_[^_]*)_([^_]*)_([^_]*)(_sum|_count)?"
            target_label: "service_method"
            replacement: "$3"
          - source_labels: ["__name__"]
            regex: "handler_latency_(yb_[^_]*)_([^_]*)_([^_]*)(_sum|_count)?"
            target_label: "__name__"
            replacement: "rpc_latency$4"
